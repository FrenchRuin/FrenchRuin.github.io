{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/dispatcher/","result":{"data":{"markdownRemark":{"html":"<h2>Dispatcher_Servlet ?</h2>\n<h3>디스패처 서블릿이란?</h3>\n<blockquote>\n<p>HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 Front Controller</p>\n</blockquote>\n<h3>디스패처 서블릿 장점</h3>\n<p><strong>web.xml</strong>의 역할을 상당히 축소시켜주었습니다. <strong>디스패처 서블릿이 해당 어플리케이션으로 들어오는 모든 요청을 핸들링</strong> 해줄 뿐 아니라, <strong>공통 작업을 처리</strong>해주면서 상당히 간단해졌습니다.</p>\n<h3>정적자원 (Static Resources) 의 처리</h3>\n<p>디스패처 서블릿이 모든 요청을 처리하다보니, 정적자원(HTML,CSS,Image...)의 요청마저 가로채기 때문에 정적자원을 제대로 불러오지 못하는 상황이 발생하곤 했습니다.</p>\n<blockquote>\n<p>해결방안으로 요청에 대한 컨트롤러가 없을 경우에 2차적으로 설정된 자원 경로를 탐색하여 정적자원을 탐색합니다.</p>\n</blockquote>\n<h2>디스패처 서블릿의 동작 과정</h2>\n<p>위에서 설명한대로 <strong>적합한 컨트롤러와 메소드를 찾아 요청을 위임합니다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46.62576687116564%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABlElEQVR42nVSi27UMBDM//8QH4BUcaUSpYgLFC4kx8V52PE77/SGtdu7CkEtjS3Z69nZ2U3wn3U+n8MGYx3SosXN50dkTGIYBlhr4b2/xvZ9D6UUtNbxPbkQjPOCed3iuW1bDFzWFX6c4YYJ/Tjh/EIyzzOenrb4b5omrOuCZVkwjiMSawwkZbjd53j3/hNu0yM4FzGr6CR+nATuH3+jqBUMxfI8BftyA/7tDpI3EKxA/fUD2v0OmuVIvHNwziOvOtynGbJSYOiHWJYjCN3jcGQwPakiievg4HmJUdZY5gmDd7CihiN4q59LfnHuYuA/nq5UuqmP6IrvkGVGAuz1x+g0DPtFyNBrgSTULrRHpQjSQ1Mjnk1WsQEzeRoILanSpwN0lZOy8ZrMyxZVege2/wjTnIgwZO84JDtBViWcNaTARWjybKIGBMK3pmFZ1tdmkbgkXHQdQ13/RNMcyHgZzQ8I6i94teNvS7iq8HDY4SHboeQFkpBdWYVWt+CaUzNcnKeA8BbIwhi9taw3aLsKjWBQRuIPQr+y+xisYp0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"dispatcher_servlet\"\n        title=\"\"\n        src=\"/static/85002453c3a50cc3f399a4b01f53d600/a6d36/dispatcherservletAction.png\"\n        srcset=\"/static/85002453c3a50cc3f399a4b01f53d600/222b7/dispatcherservletAction.png 163w,\n/static/85002453c3a50cc3f399a4b01f53d600/ff46a/dispatcherservletAction.png 325w,\n/static/85002453c3a50cc3f399a4b01f53d600/a6d36/dispatcherservletAction.png 650w,\n/static/85002453c3a50cc3f399a4b01f53d600/e548f/dispatcherservletAction.png 975w,\n/static/85002453c3a50cc3f399a4b01f53d600/6be49/dispatcherservletAction.png 1160w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ol>\n<li>클라이언트의 요청을 디스패처 서블릿이 받음.</li>\n<li>요청 정보를 통해 요청을 위임할 컨트롤러를 찾음.</li>\n<li>요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달.</li>\n<li>핸들러 어댑터가 컨트롤러로 요청을 위임.</li>\n<li>비즈니스 로직을 처리.</li>\n<li>컨트롤러가 반환값을 반환.</li>\n<li>핸들러 어댑터가 반환값을 처리.</li>\n<li>서버스이 응답을 클라이언트로 반환.</li>\n</ol>\n<blockquote>\n<p><strong>디스패처 서블릿을 통해 요청을 처리할 컨트롤러를 찾아서 위임하고 결과를 받아온다고 생각하시면 됩니다.</strong></p>\n</blockquote>\n<hr>\n<h3>1. 클라이언트의 요청을 디스패처 서블릿이 받음.</h3>\n<p>서블릿 컨텍스트(웹 컨텍스트)에서 필터들을 지나 Spring Context에서 Dispatcher Servlet이 가장 먼저 요청을 받게됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.036809815950924%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABf0lEQVR42n1S7W6jMBDk/V+q0qmKEjX0oA2kSfkw2AYDxSEYkvSaMrc4/dOrdJZGO7J3xzteO/hnKT0gUT1YdUNaGbB6wHNc4G7p494N4e85hL4gextt7oyYkDc9nGmavgmWmpLqE/L2TAUXEjWo8hQ1n5Eg+L3G4tcd3OUC/nqFVmZoBEND57yo4Xzvb4I6nBCpATve0q0GeXVEn23wLkJc5BZj/oz21bU4Jh7OIqC9DS58g1IKOH7gotISHx9XTJ+fKFqDnTggZLWNWXmA2j2iCFbQkY+Bh3iLPLSxR3yLlni9f8Qx9UlQwgnzNXUSQFUKB62xTTi8qIDo/iDMWvgvDMxfIPPuIUm0CFdo9q6F2CyhXh6gYx99+nQTPL0bjGeD6/VqLZc0lJ3sEBWdjYw61MkTWdta6yMPYCjOfCCrPZtjCMO+BH9OeURczYMZkTZnMNWhs0WBLRzJ5o0Hlo/0BJaTuBTip2BFHab0XbLa3EBDyYUCl/9HLkpw1eIvjIhQ+j8gVXgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"dispatcher_servlet\"\n        title=\"\"\n        src=\"/static/a0cbad36a56eb1a6125b22407810daaa/a6d36/dispatcherservletAction_1.png\"\n        srcset=\"/static/a0cbad36a56eb1a6125b22407810daaa/222b7/dispatcherservletAction_1.png 163w,\n/static/a0cbad36a56eb1a6125b22407810daaa/ff46a/dispatcherservletAction_1.png 325w,\n/static/a0cbad36a56eb1a6125b22407810daaa/a6d36/dispatcherservletAction_1.png 650w,\n/static/a0cbad36a56eb1a6125b22407810daaa/e548f/dispatcherservletAction_1.png 975w,\n/static/a0cbad36a56eb1a6125b22407810daaa/21b4d/dispatcherservletAction_1.png 1280w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3>2. 요청 정보를 통해 요청을 위임할 컨트롤러를 찾음.</h3>\n<p>어느 컨트롤러가 요청을 처리할 수 있는지 식별을 해야하는데, 그것을 <strong>Hanlder Mapping</strong>이 해결합니다.</p>\n<p>흔하게, <code>@Controller</code> 어노테이션으로 RequestMappingHandlerMapping으로 처리하는데, 이는 @Controller로 작성된 모든 컨트롤러를 찾아 <strong>HashMap으로 &#x3C;요청 정보, 관리 대상></strong> 으로 관리합니다.</p>\n<p>여기서 요청이오면 (HTTP Method, URI...) 등으로 요청정보를 만들고, 인터셉터등을 포함하기 위해서 <code>HandlerExecutionChain</code> 으로 감쌉니다.</p>\n<h3>3. 요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달.</h3>\n<p>HandlerAdapter라는 어댑터 인터페이스를 통해 <strong>어댑터 패턴을 적용함으로써 컨트롤러의 구현 방식에 상관없이 요청을 위임</strong></p>\n<h3>4. 핸들러 어댑터가 컨트롤러로 요청을 위임.</h3>\n<p>핸들러 어댑터가 컨트롤러로 요청을 위임한 전/후에 <strong>공통적인 전/후 처리 과정이 필요</strong>합니다.</p>\n<h3>5. 비즈니스 로직을 처리.</h3>\n<p>컨트롤러는 서비스를 호출 하고 직접 작성한 비즈니스 로직이 흘러갑니다.</p>\n<h3>6. 컨트롤러가 반환값을 반환.</h3>\n<p>비즈니스 로직이 처리된 후에는 컨트롤러가 반환값을 반환합니다. 요즘은 프론트엔드와 백엔드를 분리하고, MSA로 가기에 주로 <code>ResponseEntity</code>를 반환합니다.</p>\n<h3>7. 핸들러 어댑터가 반환값을 처리.</h3>\n<p>HandlerAdapter는 컨트롤러부터 받은 응답을 응답 처리기인 ReturnValueHandler가 후처리 한 후에, 디스패처 서블릿으로 돌려줍니다. 만약 컨트롤러가 ResponseEntity를 반환하면 응답객체를 직렬화하여 응답상태를 설정, View를 반환 하면 ViewResolver를 통해 View를 반환합니다.</p>\n<h3>8. 서버의 응답을 클라이언트로 반환.</h3>\n<p>Dispatcher Servlet을 통해 반환되는 응답은 다시 Filter들을 거쳐 Client에게 반환됩니다.\r\n여기서 응답이 Data라면 그대로 반환되지만, 응답이 화면이라면 View이름에 걸맞게 ViewResolver가 적절한 화면을 내려줍니다.</p>\n<hr>\n<h2>마무리하면서</h2>\n<p>스프링을 공부하던 중에 디스패처 서블릿의 개념을 공부해보았습니다.\r\n소스코드로 분석하신 분도 계시던데 정말 대단하다는 생각이 들었습니다.</p>\n<p>여러분께 도움이 되었으면 좋겠습니다.</p>\n<p>참조 :: <a href=\"https://mangkyu.tistory.com/18\">https://mangkyu.tistory.com/18</a></p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","frontmatter":{"title":"Distpatcher_Servlet 개념과 동작과정","desc":"Distpatcher_Servlet","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABF0lEQVR42q2Sz2rCQBDGfbe+gg/Qd+g7FIQePLaXniyWgvZQQk8FS0UkglWEVg9SbYJBbWpizL/NZr9OVpSAFRvpwDI7y+6Pb+ebHA6G2LP/PXL4Q4TcQ8BdcMEIKY4Dbh6+ThSc105QbOTR0u8RC54duIG5bIFL9RT1cQmj7zY0qweP2ccDF74BZXAh6xXBx1YnK1CkGr/Ob7MabrpneHgvYGiq/2OK7U9J7eSgITtAO5imviTW7kYOGRFtW5CcCRFT9sHiQNbpcdoCk0uJo43PMlS9gvqohKZ2R/WtrFt6FV3jEc8f1+gYimzF0/AK/fnLfoU+qUmW6Wqkdkb7pVToMUsuHkdwwi95J6S5dEJTqszcwyzxA6pTVWug0ZDcAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/22947ec331fd3c11b73f3c04ee279fd7/afa5c/dispatcherservlet.png","srcSet":"/static/22947ec331fd3c11b73f3c04ee279fd7/afa5c/dispatcherservlet.png 1920w","sizes":"1920px"},"sources":[{"srcSet":"/static/22947ec331fd3c11b73f3c04ee279fd7/c512e/dispatcherservlet.webp 1920w","type":"image/webp","sizes":"1920px"}]},"width":1920,"height":1080}}},"date":"2023-10-16","category":"Spring"}}},"pageContext":{"slug":"/blog/dispatcher/"}},"staticQueryHashes":["1044384444","164652340","1840460387"],"slicesMap":{}}